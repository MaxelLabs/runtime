<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maxellabs 3D Engine - WebGL RHI æ¸²æŸ“æ¼”ç¤º</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 300;
        }

        .demo-section {
            margin-bottom: 30px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        #webglCanvas {
            width: 100%;
            height: 500px;
            display: block;
            background: linear-gradient(45deg, #000428, #004e92);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }

        .control-group h3 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 1.1em;
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin: 5px;
            transition: all 0.3s ease;
            width: calc(100% - 10px);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .info-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 12px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .label {
            font-weight: bold;
            color: #495057;
        }

        .value {
            color: #6c757d;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #f5c6cb;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-ready { background: #28a745; }
        .status-error { background: #dc3545; }
        .status-loading { background: #ffc107; }

        .code-output {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 11px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® Maxellabs 3D Engine WebGL RHI æ¼”ç¤º</h1>
        
        <div class="demo-section">
            <div class="canvas-container">
                <canvas id="webglCanvas"></canvas>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>ğŸ¯ æ¸²æŸ“æ§åˆ¶</h3>
                <button onclick="demo.startRender()">å¼€å§‹æ¸²æŸ“</button>
                <button onclick="demo.stopRender()">åœæ­¢æ¸²æŸ“</button>
                <button onclick="demo.clearCanvas()">æ¸…ç©ºç”»å¸ƒ</button>
                <button onclick="demo.testCoreRenderer()">æµ‹è¯• Core æ¸²æŸ“å™¨</button>
            </div>

            <div class="control-group">
                <h3>ğŸ”§ è®¾å¤‡ä¿¡æ¯</h3>
                <button onclick="demo.showDeviceInfo()">æ˜¾ç¤ºè®¾å¤‡ä¿¡æ¯</button>
                <button onclick="demo.checkExtensions()">æ£€æŸ¥æ‰©å±•</button>
                <button onclick="demo.showRHICapabilities()">RHI èƒ½åŠ›</button>
                <button onclick="demo.logToConsole()">æ§åˆ¶å°æ—¥å¿—</button>
            </div>

            <div class="control-group">
                <h3>ğŸ“Š è°ƒè¯•ä¿¡æ¯</h3>
                <button onclick="demo.exportDeviceInfo()">å¯¼å‡ºè®¾å¤‡ä¿¡æ¯</button>
                <button onclick="demo.testWebGLFeatures()">æµ‹è¯• WebGL ç‰¹æ€§</button>
                <button onclick="demo.measurePerformance()">æ€§èƒ½æµ‹è¯•</button>
            </div>
        </div>

        <div id="infoPanel" class="info-panel">
            <div class="info-row">
                <span class="label">çŠ¶æ€:</span>
                <span class="value">
                    <span id="statusIndicator" class="status-indicator status-loading"></span>
                    <span id="statusText">åˆå§‹åŒ–ä¸­...</span>
                </span>
            </div>
            <div class="info-row">
                <span class="label">RHI åç«¯:</span>
                <span class="value" id="rhiBackend">-</span>
            </div>
            <div class="info-row">
                <span class="label">è®¾å¤‡:</span>
                <span class="value" id="deviceName">-</span>
            </div>
            <div class="info-row">
                <span class="label">ä¾›åº”å•†:</span>
                <span class="value" id="vendorName">-</span>
            </div>
            <div class="info-row">
                <span class="label">ç€è‰²å™¨ç‰ˆæœ¬:</span>
                <span class="value" id="shaderVersion">-</span>
            </div>
            <div class="info-row">
                <span class="label">æœ€å¤§çº¹ç†å°ºå¯¸:</span>
                <span class="value" id="maxTextureSize">-</span>
            </div>
            <div class="info-row">
                <span class="label">FPS:</span>
                <span class="value" id="fpsCounter">0</span>
            </div>
        </div>

        <div id="outputPanel" class="code-output" style="display: none;"></div>
        <div id="errorPanel" style="display: none;"></div>
    </div>

    <script type="module">
        // å¯¼å…¥ Core åŒ…ç»„ä»¶è¿›è¡Œå®Œæ•´æ¸²æŸ“æµ‹è¯•
        import { WebGLDevice } from '../../rhi/src/webgl/GLDevice.js';
        import { RenderTest } from '../src/renderer/render-test.js';
        import { RHIBackend } from '../src/interface/rhi/types/enums.js';

        class WebGLRenderDemo {
            constructor() {
                this.canvas = null;
                this.rhiDevice = null;
                this.renderTest = null;
                this.isRendering = false;
                this.frameCount = 0;
                this.lastTime = 0;
                this.animationId = null;
                this.deviceInfo = null;
                this.coreInitialized = false;
            }

            async init() {
                try {
                    this.updateStatus('loading', 'åˆå§‹åŒ– WebGL è®¾å¤‡...');
                    
                    // è·å–ç”»å¸ƒ
                    this.canvas = document.getElementById('webglCanvas');
                    if (!this.canvas) {
                        throw new Error('æ— æ³•æ‰¾åˆ°ç”»å¸ƒå…ƒç´ ');
                    }

                    // è®¾ç½®ç”»å¸ƒå°ºå¯¸
                    this.resizeCanvas();
                    window.addEventListener('resize', () => this.resizeCanvas());

                    // åˆ›å»º RHI WebGL è®¾å¤‡
                    this.initRHIDevice();

                    // åˆå§‹åŒ– Core æ¸²æŸ“æµ‹è¯•
                    await this.initCoreRenderer();

                    // æ›´æ–°ç•Œé¢æ˜¾ç¤º
                    this.updateDeviceInfo();
                    this.updateStatus('ready', 'Core æ¸²æŸ“ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ');

                    // å¼€å§‹æ¸²æŸ“å¾ªç¯
                    this.startRender();

                } catch (error) {
                    this.handleError(error);
                }
            }

            initRHIDevice() {
                // åˆ›å»º RHI WebGL è®¾å¤‡
                this.rhiDevice = new WebGLDevice(this.canvas, {
                    antialias: true,
                    alpha: true,
                    depth: true,
                    stencil: false,
                    powerPreference: 'high-performance'
                });

                // æ”¶é›†è®¾å¤‡ä¿¡æ¯
                this.collectDeviceInfo();
            }

            async initCoreRenderer() {
                if (!this.rhiDevice) {
                    throw new Error('RHI è®¾å¤‡å°šæœªåˆå§‹åŒ–');
                }

                // åˆ›å»º Core æ¸²æŸ“æµ‹è¯•å®ä¾‹
                this.renderTest = new RenderTest(this.rhiDevice);
                
                // åˆå§‹åŒ–æµ‹è¯•åœºæ™¯
                this.renderTest.initializeTestScene();
                
                this.coreInitialized = true;
            }

            collectDeviceInfo() {
                if (!this.rhiDevice) return;

                // ä» RHI è®¾å¤‡è·å–ä¿¡æ¯
                this.deviceInfo = this.rhiDevice.getInfo();
                
                // åŒæ—¶è·å–åŸç”Ÿ WebGL ä¿¡æ¯ç”¨äºè¯¦ç»†åˆ†æ
                const gl = this.rhiDevice.getGL();
                this.deviceInfo.nativeGL = {
                    vendor: gl.getParameter(gl.VENDOR),
                    renderer: gl.getParameter(gl.RENDERER),
                    version: gl.getParameter(gl.VERSION),
                    extensions: gl.getSupportedExtensions(),
                    contextAttributes: gl.getContextAttributes()
                };
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                const rect = container.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';

                if (this.rhiDevice) {
                    const gl = this.rhiDevice.getGL();
                    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }
            }

            updateDeviceInfo() {
                if (!this.deviceInfo) return;

                document.getElementById('rhiBackend').textContent = 
                    this.deviceInfo.backend === RHIBackend.WebGL2 ? 'WebGL 2.0' : 'WebGL 1.0';
                document.getElementById('deviceName').textContent = this.deviceInfo.deviceName || 'æœªçŸ¥';
                document.getElementById('vendorName').textContent = this.deviceInfo.vendorName || 'æœªçŸ¥';
                document.getElementById('shaderVersion').textContent = this.deviceInfo.shaderLanguageVersion || 'æœªçŸ¥';
                document.getElementById('maxTextureSize').textContent = this.deviceInfo.maxTextureSize || 'æœªçŸ¥';
            }

            updateStatus(type, text) {
                const indicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');
                
                indicator.className = `status-indicator status-${type}`;
                statusText.textContent = text;
            }

            handleError(error) {
                console.error('WebGL æ¸²æŸ“æ¼”ç¤ºé”™è¯¯:', error);
                this.updateStatus('error', `é”™è¯¯: ${error.message}`);
                
                const errorPanel = document.getElementById('errorPanel');
                errorPanel.innerHTML = `
                    <div class="error">
                        <strong>æ¸²æŸ“é”™è¯¯:</strong> ${error.message}
                        <br><br>
                        <strong>å¯èƒ½çš„è§£å†³æ–¹æ¡ˆ:</strong>
                        <ul>
                            <li>ç¡®ä¿æµè§ˆå™¨æ”¯æŒ WebGL</li>
                            <li>æ£€æŸ¥æ˜¾å¡é©±åŠ¨æ˜¯å¦æœ€æ–°</li>
                            <li>å°è¯•åœ¨æµè§ˆå™¨ä¸­å¯ç”¨ç¡¬ä»¶åŠ é€Ÿ</li>
                            <li>æ¸…é™¤æµè§ˆå™¨ç¼“å­˜å¹¶é‡æ–°åŠ è½½é¡µé¢</li>
                        </ul>
                    </div>
                `;
                errorPanel.style.display = 'block';
            }

            startRender() {
                if (this.isRendering) return;
                
                this.isRendering = true;
                this.lastTime = performance.now();
                this.frameCount = 0;
                this.render();
            }

            stopRender() {
                this.isRendering = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            render() {
                if (!this.isRendering || !this.rhiDevice) return;

                const currentTime = performance.now();
                const deltaTime = currentTime - this.lastTime;

                try {
                    // ä½¿ç”¨ RHI è®¾å¤‡è¿›è¡Œæ¸²æŸ“
                    const gl = this.rhiDevice.getGL();
                    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    
                    // ä½¿ç”¨åŠ¨æ€é¢œè‰²æ¸…å±
                    const time = currentTime * 0.001;
                    const r = Math.sin(time * 0.3) * 0.3 + 0.1;
                    const g = Math.sin(time * 0.5) * 0.3 + 0.2;
                    const b = Math.sin(time * 0.7) * 0.3 + 0.4;
                    
                    gl.clearColor(r, g, b, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                    // æ›´æ–° FPS
                    this.frameCount++;
                    if (deltaTime >= 1000) {
                        const fps = Math.round((this.frameCount * 1000) / deltaTime);
                        document.getElementById('fpsCounter').textContent = fps;
                        this.frameCount = 0;
                        this.lastTime = currentTime;
                    }

                } catch (error) {
                    this.handleError(error);
                    return;
                }

                this.animationId = requestAnimationFrame(() => this.render());
            }

            clearCanvas() {
                if (!this.rhiDevice) return;

                try {
                    const gl = this.rhiDevice.getGL();
                    gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                } catch (error) {
                    this.handleError(error);
                }
            }

            testCoreRenderer() {
                if (!this.coreInitialized) {
                    alert('Core æ¸²æŸ“å™¨å°šæœªåˆå§‹åŒ–ï¼Œè¯·ç¨ç­‰...');
                    return;
                }

                try {
                    this.updateStatus('testing', 'æµ‹è¯• Core æ¸²æŸ“ç®¡çº¿...');
                    
                    // æ‰§è¡Œ Core æ¸²æŸ“æµ‹è¯•
                    const success = this.renderTest.executeRenderTest();
                    
                    if (success) {
                        this.updateStatus('ready', 'Core æ¸²æŸ“æµ‹è¯•æˆåŠŸï¼');
                        
                        // è·å–æ¸²æŸ“ç»Ÿè®¡
                        const stats = this.renderTest.renderer?.getStatistics();
                        if (stats) {
                            alert(`ğŸ‰ Core æ¸²æŸ“æµ‹è¯•æˆåŠŸï¼

æ¸²æŸ“ç»Ÿè®¡ä¿¡æ¯:
â€¢ ç»˜åˆ¶è°ƒç”¨: ${stats.drawCalls}
â€¢ ä¸‰è§’å½¢æ•°: ${stats.triangles}
â€¢ é¡¶ç‚¹æ•°: ${stats.vertices}
â€¢ å¯¹è±¡æ•°: ${stats.objects}
â€¢ å¸§æ—¶é—´: ${stats.frameTime.toFixed(2)}ms
â€¢ FPS: ${stats.fps}

è¿™è¯æ˜ Core åŒ…çš„å®Œæ•´æ¸²æŸ“ç®¡çº¿æ­£å¸¸å·¥ä½œï¼
åŒ…æ‹¬: Scene â†’ GameObject â†’ Material â†’ Geometry â†’ Renderer`);
                        } else {
                            alert('ğŸ‰ Core æ¸²æŸ“æµ‹è¯•æˆåŠŸï¼\n\nå®Œæ•´çš„æ¸²æŸ“ç®¡çº¿å·²éªŒè¯æ­£å¸¸å·¥ä½œã€‚');
                        }
                    } else {
                        this.updateStatus('error', 'Core æ¸²æŸ“æµ‹è¯•å¤±è´¥');
                        alert('âŒ Core æ¸²æŸ“æµ‹è¯•å¤±è´¥\n\nè¯·æ£€æŸ¥æ§åˆ¶å°é”™è¯¯ä¿¡æ¯');
                    }
                } catch (error) {
                    this.handleError(error);
                    alert(`âŒ Core æ¸²æŸ“æµ‹è¯•å¼‚å¸¸: ${error.message}`);
                }
            }

            renderColorfulBackground() {
                if (!this.gl) return;

                try {
                    const colors = [
                        [1.0, 0.0, 0.0, 1.0], // çº¢è‰²
                        [0.0, 1.0, 0.0, 1.0], // ç»¿è‰²
                        [0.0, 0.0, 1.0, 1.0], // è“è‰²
                        [1.0, 1.0, 0.0, 1.0], // é»„è‰²
                        [1.0, 0.0, 1.0, 1.0], // ç´«è‰²
                    ];
                    
                    const randomColor = colors[Math.floor(Math.random() * colors.length)];
                    this.gl.clearColor(...randomColor);
                    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                    
                    this.updateStatus('ready', `è®¾ç½®èƒŒæ™¯é¢œè‰²ä¸º RGBA(${randomColor.map(v => Math.round(v*255)).join(', ')})`);
                } catch (error) {
                    this.handleError(error);
                }
            }

            showDeviceInfo() {
                if (!this.deviceInfo) {
                    alert('è®¾å¤‡ä¿¡æ¯å°šæœªæ”¶é›†');
                    return;
                }

                const info = this.deviceInfo;
                const nativeGL = info.nativeGL || {};
                const isWebGL2 = info.backend === RHIBackend.WebGL2;
                
                const details = `Maxellabs Core æ¸²æŸ“ç³»ç»Ÿä¿¡æ¯:

ğŸ® Core ç³»ç»ŸçŠ¶æ€:
â€¢ RHI åç«¯: ${isWebGL2 ? 'WebGL 2.0' : 'WebGL 1.0'}
â€¢ Core æ¸²æŸ“å™¨: ${this.coreInitialized ? 'âœ… å·²åˆå§‹åŒ–' : 'âŒ æœªåˆå§‹åŒ–'}
â€¢ æ¸²æŸ“æµ‹è¯•: ${this.renderTest ? 'âœ… å¯ç”¨' : 'âŒ ä¸å¯ç”¨'}

ğŸ”§ åŸºæœ¬ä¿¡æ¯:
â€¢ è®¾å¤‡åç§°: ${info.deviceName}
â€¢ ä¾›åº”å•†: ${info.vendorName}
â€¢ ç€è‰²å™¨ç‰ˆæœ¬: ${info.shaderLanguageVersion}
â€¢ æœ€å¤§çº¹ç†å°ºå¯¸: ${info.maxTextureSize}

ğŸ¯ RHI åŠŸèƒ½ç‰¹æ€§:
â€¢ æ”¯æŒå„å‘å¼‚æ€§è¿‡æ»¤: ${info.supportsAnisotropy ? 'âœ…' : 'âŒ'}
â€¢ æ”¯æŒå¤šé‡é‡‡æ ·: ${info.supportsMSAA ? 'âœ…' : 'âŒ'}
â€¢ æœ€å¤§é‡‡æ ·æ•°: ${info.maxSampleCount}
â€¢ æœ€å¤§ç»‘å®šæ•°: ${info.maxBindings}

ğŸ“Š åŸç”Ÿ WebGL ä¿¡æ¯:
â€¢ æ¸²æŸ“å™¨: ${nativeGL.renderer || 'æœªçŸ¥'}
â€¢ ä¾›åº”å•†: ${nativeGL.vendor || 'æœªçŸ¥'}
â€¢ ç‰ˆæœ¬: ${nativeGL.version || 'æœªçŸ¥'}

ğŸ”Œ æ”¯æŒçš„æ‰©å±•: ${nativeGL.extensions?.length || 0} ä¸ª`;

                alert(details);
            }

            checkExtensions() {
                if (!this.deviceInfo) {
                    alert('è®¾å¤‡ä¿¡æ¯å°šæœªæ”¶é›†');
                    return;
                }

                const extensions = this.deviceInfo.nativeGL?.extensions || [];
                alert(`æ”¯æŒçš„ WebGL æ‰©å±• (${extensions.length} ä¸ª):\n\n${extensions.sort().join('\n')}`);
            }

            showRHICapabilities() {
                if (!this.deviceInfo) {
                    alert('è®¾å¤‡ä¿¡æ¯å°šæœªæ”¶é›†');
                    return;
                }

                const extensions = this.deviceInfo.nativeGL?.extensions || [];
                const isWebGL2 = this.deviceInfo.backend === RHIBackend.WebGL2;
                
                const capabilities = {
                    depthTexture: extensions.includes('WEBGL_depth_texture'),
                    textureFloat: extensions.includes('OES_texture_float'),
                    textureHalfFloat: extensions.includes('OES_texture_half_float'),
                    anisotropicFiltering: extensions.includes('EXT_texture_filter_anisotropic'),
                    vertexArrayObject: extensions.includes('OES_vertex_array_object') || isWebGL2,
                    instancedArrays: extensions.includes('ANGLE_instanced_arrays') || isWebGL2,
                    multipleRenderTargets: extensions.includes('WEBGL_draw_buffers') || isWebGL2,
                    standardDerivatives: extensions.includes('OES_standard_derivatives') || isWebGL2,
                };

                const capabilityText = Object.entries(capabilities)
                    .map(([key, value]) => `â€¢ ${key}: ${value ? 'âœ… æ”¯æŒ' : 'âŒ ä¸æ”¯æŒ'}`)
                    .join('\n');

                alert(`RHI ç¡¬ä»¶æŠ½è±¡å±‚èƒ½åŠ›æ£€æµ‹:\n\n${capabilityText}`);
            }

            logToConsole() {
                console.group('ğŸ® Maxellabs WebGL RHI è®¾å¤‡ä¿¡æ¯');
                console.log('è®¾å¤‡ä¿¡æ¯:', this.deviceInfo);
                console.log('RHI è®¾å¤‡:', this.rhiDevice);
                console.log('Core æ¸²æŸ“æµ‹è¯•:', this.renderTest);
                console.log('ç”»å¸ƒ:', this.canvas);
                console.groupEnd();
                
                this.updateStatus('ready', 'è®¾å¤‡ä¿¡æ¯å·²è¾“å‡ºåˆ°æ§åˆ¶å°');
            }

            exportDeviceInfo() {
                if (!this.deviceInfo) {
                    alert('è®¾å¤‡ä¿¡æ¯å°šæœªæ”¶é›†');
                    return;
                }

                const exportData = {
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    webglInfo: this.deviceInfo,
                    canvasSize: {
                        width: this.canvas.width,
                        height: this.canvas.height,
                        devicePixelRatio: window.devicePixelRatio
                    }
                };

                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `webgl-device-info-${Date.now()}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
                this.updateStatus('ready', 'è®¾å¤‡ä¿¡æ¯å·²å¯¼å‡ºä¸º JSON æ–‡ä»¶');
            }

            testWebGLFeatures() {
                if (!this.rhiDevice) return;
                
                const gl = this.rhiDevice.getGL();

                const output = document.getElementById('outputPanel');
                output.style.display = 'block';
                
                let testResults = 'ğŸ§ª WebGL åŠŸèƒ½æµ‹è¯•ç»“æœ:\n\n';
                
                try {
                    // æµ‹è¯•ç¼“å†²åŒºåˆ›å»º
                    const buffer = gl.createBuffer();
                    testResults += `âœ… ç¼“å†²åŒºåˆ›å»º: æˆåŠŸ\n`;
                    gl.deleteBuffer(buffer);
                    
                    // æµ‹è¯•çº¹ç†åˆ›å»º
                    const texture = gl.createTexture();
                    testResults += `âœ… çº¹ç†åˆ›å»º: æˆåŠŸ\n`;
                    gl.deleteTexture(texture);
                    
                    // æµ‹è¯•ç€è‰²å™¨ç¼–è¯‘
                    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                    testResults += `âœ… ç€è‰²å™¨åˆ›å»º: æˆåŠŸ\n`;
                    gl.deleteShader(vertexShader);
                    gl.deleteShader(fragmentShader);
                    
                    // æµ‹è¯•æ¸²æŸ“ç¼“å†²åŒº
                    const renderbuffer = gl.createRenderbuffer();
                    testResults += `âœ… æ¸²æŸ“ç¼“å†²åŒºåˆ›å»º: æˆåŠŸ\n`;
                    gl.deleteRenderbuffer(renderbuffer);
                    
                    // æµ‹è¯•å¸§ç¼“å†²åŒº
                    const framebuffer = gl.createFramebuffer();
                    testResults += `âœ… å¸§ç¼“å†²åŒºåˆ›å»º: æˆåŠŸ\n`;
                    gl.deleteFramebuffer(framebuffer);
                    
                    // æµ‹è¯• RHI è®¾å¤‡åŠŸèƒ½
                    testResults += `âœ… RHI è®¾å¤‡: ${this.deviceInfo.backend === RHIBackend.WebGL2 ? 'WebGL2' : 'WebGL1'}\n`;
                    testResults += `âœ… Core æ¸²æŸ“å™¨: ${this.coreInitialized ? 'å·²åˆå§‹åŒ–' : 'æœªåˆå§‹åŒ–'}\n`;
                    
                } catch (error) {
                    testResults += `âŒ æµ‹è¯•å¤±è´¥: ${error.message}\n`;
                }
                
                output.textContent = testResults;
                this.updateStatus('ready', 'WebGL åŠŸèƒ½æµ‹è¯•å®Œæˆ');
            }

            measurePerformance() {
                if (!this.rhiDevice) return;
                
                const gl = this.rhiDevice.getGL();

                const output = document.getElementById('outputPanel');
                output.style.display = 'block';
                
                let perfResults = 'âš¡ WebGL æ€§èƒ½æµ‹è¯•:\n\n';
                const startTime = performance.now();
                
                try {
                    // ç»˜åˆ¶è°ƒç”¨æ€§èƒ½æµ‹è¯•
                    const iterations = 1000;
                    
                    perfResults += `æµ‹è¯• ${iterations} æ¬¡æ¸…å±æ“ä½œ...\n`;
                    const clearStart = performance.now();
                    
                    for (let i = 0; i < iterations; i++) {
                        gl.clearColor(Math.random(), Math.random(), Math.random(), 1.0);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                    }
                    
                    const clearEnd = performance.now();
                    const clearTime = clearEnd - clearStart;
                    
                    perfResults += `æ¸…å±æ“ä½œæ€»è€—æ—¶: ${clearTime.toFixed(2)}ms\n`;
                    perfResults += `å¹³å‡æ¯æ¬¡æ¸…å±: ${(clearTime / iterations).toFixed(4)}ms\n`;
                    perfResults += `ç†è®ºæœ€å¤§æ¸…å±FPS: ${(1000 / (clearTime / iterations)).toFixed(0)}\n\n`;
                    
                    // ä¸Šä¸‹æ–‡çŠ¶æ€åˆ‡æ¢æµ‹è¯•
                    perfResults += `æµ‹è¯•ä¸Šä¸‹æ–‡çŠ¶æ€åˆ‡æ¢...\n`;
                    const stateStart = performance.now();
                    
                    for (let i = 0; i < iterations; i++) {
                        gl.enable(gl.DEPTH_TEST);
                        gl.disable(gl.DEPTH_TEST);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.BLEND);
                    }
                    
                    const stateEnd = performance.now();
                    const stateTime = stateEnd - stateStart;
                    
                    perfResults += `çŠ¶æ€åˆ‡æ¢æ€»è€—æ—¶: ${stateTime.toFixed(2)}ms\n`;
                    perfResults += `å¹³å‡æ¯æ¬¡çŠ¶æ€åˆ‡æ¢: ${(stateTime / (iterations * 4)).toFixed(4)}ms\n\n`;
                    
                    const totalTime = performance.now() - startTime;
                    perfResults += `æ€»æµ‹è¯•æ—¶é—´: ${totalTime.toFixed(2)}ms\n`;
                    
                } catch (error) {
                    perfResults += `âŒ æ€§èƒ½æµ‹è¯•å¤±è´¥: ${error.message}\n`;
                }
                
                output.textContent = perfResults;
                this.updateStatus('ready', 'WebGL æ€§èƒ½æµ‹è¯•å®Œæˆ');
            }
        }

        // åˆ›å»ºå…¨å±€æ¼”ç¤ºå®ä¾‹
        window.demo = new WebGLRenderDemo();

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            window.demo.init();
        });
    </script>
</body>
</html> 